exp: 10(square 1 - 10):

		TTL SQUARE
        AREA SQUARE,CODE,READONLY
        ENTRY

START
        LDR R0, =Lookup
        LDR R1, Value
        LDR R2, =Result
        MOV R1, R1, LSL #0x2
        ADD R0, R0, R1
        LDR R3, [R0]
        STR R3, [R2]

STOP    B STOP

        AREA SRC, DATA, READONLY
Lookup  DCD 0,1,4,9,16,25,36,49,64,81,100
Value   DCD 0x00000007
        ALIGN

        AREA DST, DATA
Result  DCD 0x00000000
        ALIGN
        END
------------------------------------

seven segment: EXP - 9:


#include<LPC214X.h>
void delay();
unsigned int i,j,k;
unsigned int ar[10]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};
int main() {
	PINSEL0=0X00000000;
	IO0DIR=0X000000FF;
	while(1) {
		for(i=0;i<10;i++) {
			IO0SET=ar[i];
			delay();
			IO0CLR=ar[i];
		}
	}
	return 0;
}
void delay() {
	for(j=0;j<1000;j++)
	for(k=0;k<400;k++);
}

--------------------------------------

Sensor Interfacing - EXP - 4:

#include <reg51.h>
#define input P1;
double newtemp,pass1,pass2,T; //variables used
//LCD
sbit rs = P3^0; //registerselect pin
sbit rw = P3^1; //read write pin
sbit e = P3^2; //enable pin
//ADC
sbit rd=P3^7; //defines rd pin of ADC use for reading purposes
sbit wr=P3^6; // define wr pin of ADC use for writing purposes
sbit intr=P3^4; //defines intr pin use for sending interrupts from microcontroller
void delay(unsigned int time) { //Function to provide time delay in msec.
	int i,j ;
	for(i=0;i<time;i++)
	for(j=0;j<1275;j++);
}
double adc() { // Function to read the values from ADC and send to controller.
	double temp;
	rd=1;
	wr=0;
	delay(1);
	wr=1;
	while(intr==1); {
		rd=0;
		temp=input;
		delay(3);
	}
	return temp;
}
void lcdcmd(unsigned char item) { //Function to send commands to LCD see command tables in LCD Link
	P2 = item;
	rs= 0;
	rw=0;
	e=1; //send to high to low pulse while writing
	delay(1);
	e=0;
}
void lcddata(double item) { //Function to senddata to LCD
	P2 = item;
	rs= 1;
	rw=0;
	e=1; //send high to low pulse while writing
	delay(1);
	e=0;
}
void disp_temp(double num) { //displays number on LCD
	unsigned char UnitDigit = 0; //It will contain unit digit of number
	unsigned char TenthDigit = 0; //It will contain 10th position digit of number
	unsigned char HundDigit = 0; //It will contain 100th position digit of number
	unsigned char decimal=0; //It will contain the decimal position of number
	int point;
	point=num*10;
	HundDigit=(num/100);
	if( HundDigit != 0) // If it is zero, then don't display
	lcddata(HundDigit+0x30); // Make Character of HundDigit and then display it on LCD
	TenthDigit = num - HundDigit*100; // Findout Tenth Digit
	TenthDigit = TenthDigit/10;
	if (HundDigit==0 && TenthDigit==0){} // If it is zero, then don't display
	else
	lcddata(TenthDigit+0x30); // Make Char of TenthDigit and then display it on LCD
	UnitDigit = num - HundDigit*100;
	UnitDigit = UnitDigit - TenthDigit*10;
	lcddata(UnitDigit+0x30); // Make Char of UnitDigit and then display it on LCD
	lcddata('.');
	decimal=(point%10);
	lcddata (decimal+0x30); // Make Char of Decimal Digit and then display it on LCD
	lcddata(' '); lcddata('C');
}
void read() { // Displays "READING" while controller reads from ADC
	lcdcmd(0x0E); //turn display ON for cursor blinking
	lcdcmd(0x01); //clear screen
	lcdcmd(0x06); //increment cursor
	lcddata('R');lcddata('E');lcddata('A');lcddata('D');lcddata('I');lcddata('N');lcddata('G');lcddata(' ');
}
void main() {
	P0=0x00; //intialize port 0 to low use while controller reads the temperature from
	//ADC
	read(); // show reading on LCD while controller reads from ADC
	while(1) { // use for checking errors while reading the value from ADC
		newtemp=adc(); //reads first value from ADC
		delay(60); //waits 60 msec
		pass1=adc(); // reads the Second value from ADC
		delay(60); // waits 60 msec
		if (newtemp==pass1) { //compare first and second value
			break; // if first and second value is same breaks the loop
		}
	}
	while(1) { //enters in the permanent loop
		T=160; //set reference voltage acting multiplier factor for temperature accuration
	newtemp=(((newtemp*T)/255)); //converts the temperature value according to reference adjusted in decimal
	lcdcmd(0x0E); //turn display ON for cursor blinking
	lcdcmd(0x01); //clear screen
	lcdcmd(0x06); //increment
	disp_temp(newtemp); //show temperature
	delay(300); //waits 3sec before re-measure the value of temperature
	while(1) { 
		newtemp=adc();
		delay(60);
		pass1=adc();
		delay(60);
		pass2=adc();
		if (newtemp==pass1) {
			if(pass1==pass2) {
				break; 
			}
		}
	}// end ADC while loop
	} // end while permanent loop
} // end main loop


---------------------------------------------

ARM Basic Program:  EXP - 8:

#include<lpc214x.h>
void delay();
void main() {
	PINSEL0=0x00000000;
	IO0DIR=0XFFFFFFFF;
	while(1) {
		IOSET0=0XFFFFFFFF;
		delay();
		IOCLR0=0XFFFFFFFF;
		delay();
	}
}
void delay() {
	int i;
	for(i=0;i<200;i++) {
	}
}


-------------------------------------------
PANTECH
ADC - 8051 - EXP no - 6:


Address	Opcode		Mnemonics
9100	74 90		MOV A,#90
9102	90 40 03	MOV DPTR,#4003
9105	F0		MOVX @DPTR,A
9106	90 40 01	MOV DPTR,#4001
9109	74 01		MOV A,#01
9108	F0		MOVX @DPTR,A
910C	74 31		MOV A,#31
910E	F0		MOVX @DPTR,A
910F	74 01		MOV A,#01
9111	F0		BACK: MOVX @DPTR,A
9112	54 01		ANL A,#01
9114	30 0A FA	JNB 0A,BACK
9117	74 40		MOV A,#40
9119	F0		MOVX @DPTR,A
911A	12 91 24	LCALL DELAY
911D	90 40 00	MOV DPTR,#4000
9120	E0		MOVX A,@DPTR
9121	12 00 86	LCALL 0086
9124	78 FF		DELAY: MOV R0,#FF
9126	79 FF		LOP: MOV R1,#FF
9128	D9 FE		LOP1: DJNZ R1,LOP1
912A	D8 FA		DJNZ R0,LOP
912C	22		RET



--------------------------------------
PANTECH
Stepper Motor 8051 - EXP NO - 7:

ADDRESS	OPCODE		MNEMONICS
9100	74 80		MOV A, #80
9102	90 40 03	MOV DPTR, #4003
9105	F0		MOVX @DPTR, A
9106	90 92 00	START: MOV DPTR, #9200
9109	A9 82		MOV R1, DPL
910B	AA 83		MOV R2, DPH
910D	78 04		MOV R0, #04
910F	E0		REP: MOVX A, @DPTR
9110	90 40 00	MOV DPTR, #4000
9113	F0		MOVX @DPTR, A
9114	12 91 20	LCALL DELY
9117	09		INC R1
9118	89 82		MOV DPL, R1
911A	8A 83		MOV DPH, R2
911C	D8 F1		DJNZ R0, REP
911E	80 E6		SJMP START
9120	7F 03		DELY: MOV R7, #03
9122	7E 0A		LOP3: MOV R6, #0A
9124	7B FF		LOP2: MOV R3, #FF
9126	DB FE		LOP1: DJNZ R3, LOP1
9128	DE FA		DJNZ R6, LOP2
912A	DF F6		DJNZ R7, LOP3
912C	22		RET


------------------------------------
PANTECH
stepper motor of 8086 - EXP NO - 3:


ADDRESS	OPCODE		MNEMONICS
1100	B0 80		MOV AL, 80
1102	BA 36 FF	MOV DX, FF36
1105	EE		OUT DX, AL
1106	BE 00 12	START: MOV SI, 1200
1109	B3 04		MOV BL, 04
110B	8A 04		REPEAT: MOV AL, [SI]
110D	BA 30 FF	MOV DX, FF30
1110	EE		OUT DX, AL
1111	EB 07 00	CALL DELAY
1114	46		INC SI
1115	FE CB		DEC BL
1117	75 F2		JNE REPEAT
1119	EB EB		JMP START
111B	B9 03 09	DELAY: MOV CX, 0903
111E	49		LOOP: DEC CX
111F	75 FD		JNE LOOP
1121	C3		RET


For clockwise: 0A 06 05 09
-------------------------------

PANTECH
EXP - 1 : same this for addition:

ADDRESS	MNEMONICS		OPCODE	COMMENTS
1100	MOV AX, 1315		C73678	Move the 1st number to AX register
1103	MOV BX, 1212		C738943	Move the 2nd number to AX register
1106	SUB AX, BX		2978	Subtract both the numbers
1108	MOV [1200], AX		8F060013	Store the result to memory position
101A	HLT	FA		Stop the program



-------------------------------
PANTECH
EXP - 1 multiple: same this for division:

ADDRESS	MNEMONICS		OPCODE		COMMENTS
1100	MOV AX, 0012		C7067415	Move the 1st number to AX register
1103	MOV BX, 0013		C7C33589	Move the 2nd number to BX register
1106	MUL AX, BX		0108		Multiply both numbers
1108	MOV [1200], AX		89060013	Store the result to memory location
101B	MOV [1200], DX		89060013	Store the result to memory location
101E	HLT			FA		Stop the program


-----------------------------
PANTECH
EXP NO 2 - swap in 8086: this is for 8 bit add another INC and DEC for 16 bit :

ADDRESS	LABEL	MNEMONICS	COMMENTS
1000		MOV SI, 1200	Load index register SI with address 1200H
1003		MOV AX, [SI]	Load AX with the value stored at memory
1005		INC SI		Increment SI (SI = 1201)
1007		MOV BX, [SI]	Store BX's value stored at memory address
1009		MOV [SI], AX	Store AX value in SI
100C		DEC SI		Decrement SI
100E		MOV [SI], BX	Store BX's value at memory
1010		HLT		Halt Execution



EXP NO 7 - STEPPER MOTOR 8051


| ADDRESS | OPCODE     | MNEMONICS               |
|---------|------------|-------------------------|
| 9100    | 74 80      | MOV A,#80               |
| 9102    | 90 40 03   | MOV DPTR,#4003          |
| 9105    | F0         | MOVX @DPTR,A            |
| 9106    | 90 92 00   | START : MOV DPTR,#9200  |
| 9109    | A9 82      | MOV R1,DPL              |
| 910B    | AA 83      | MOV R2,DPH              |
| 910D    | 78 04      | MOV R0, #04             |
| 910F    | E0         | REP : MOVX A,@DPTR      |
| 9110    | 90 40 00   | MOV DPTR,#4000          |
| 9113    | F0         | MOVX @DPTR,A            |
| 9114    | 12 91 20   | LCALL DELY              |
| 9117    | 09         | INC R1                  |
| 9118    | 89 82      | MOV DPL,R1              |
| 911A    | 8A 83      | MOV DPH,R2              |
| 911C    | D8 F1      | DJNZ R0, REP            |
| 911E    | 80 E6      | SJMP START              |
| 9120    | 7F 03      | DELY : MOV R7,#03       |
| 9122    | 7E 0A      | LOP3 : MOV R6,#0A       |
| 9124    | 7B FF      | LOP2 : MOV R3,#FF       |
| 9126    | DB FE      | LOP1 : DJNZ R3, LOP1    |
| 9128    | DE FA      | DJNZ R6,LOP2            |
| 912A    | DF F6      | DJNZ R7,LOP3            |
| 912C    | 22         | RET                     |
